In this step, we will take a snapshot of our Kafka volumes and show how it can be recovered from the snapshot.

### Step: Take snapshot using kubectl

First, take a look at px-snap.yaml ```cat px-snap.yaml```{{execute T1}}. Notice that when you define the volume group name Portworx will quiesce I/O on all volumes before triggering their snapshots.

```
kubectl create -f px-snap.yaml
```{{execute T1}}

You can see the snapshots using the following command:
```
kubectl get volumesnapshot,volumesnapshotdatas
```{{execute T1}}

Now we're going to go ahead and do something stupid because it's Katacoda and we're here to learn.

```
kubectl exec -it kafka-cli bash
./bin/kafka-topics.sh --zookeeper zk-headless:2181 --delete --topic test
./bin/kafka-topics.sh --zookeeper zk-headless:2181 --list
```{{execute T1}}

Ok, so we deleted our database, what now? Restore your snapshot and cary on.

### Step: Restore the snapshot and see your data is still there

Snapshots are just like volumes so we can go ahead and use it to start a new instance of PostgresSQL. Note here that we're leaving the old instance to carry on with it's version of the volume and we're creating a brand new instance of PostgresSQL with the snapshot data!

First, lets create a new pvc, ``cat px-snap-pvc.yaml```{{execute T1}},  from the snapshot:
```
kubectl create -f px-snap-pvc.yaml
```{{execute T1}}

Now, lets look at the yaml: .

Now let's deploy a second PostgresSQL that uses this new PVC, ```cat postgres-app-restore.yaml```{{execute T1}}, and make sure it came up.
```
kubectl create -f postgres-app-restore.yaml
```{{execute T1}}

### Step: Verify postgres pod is ready

Below commands wait till the postgres pods are in ready state.
```
watch kubectl get pods -l app=postgres-snap -o wide
```{{execute T1}}

When the pod is in Running state then then hit ```clear```{{execute interrupt}} to ctrl-c and clear the screen.
