In this step, we will take a snapshot, simulate destroy our database, and recover from the snapshot

### Step: Take snapshot using kubectl

We're going to use STORK to take a 3DSnapshot of our Cassandra cluster. Take a look at the px-snap.yaml file ```cat px-snap.yaml ```{{execute T1}} and notice that we are going to force a ```nodetool flush``` command on each cluster member before we take the snapshot. As explained before, that will force all data to be written to disk. We also defined the volume group name so Portworx will quiesce I/O on all volumes before triggering their snapshots.
```
kubectl create -f px-snap.yaml
```{{execute T1}}

You can see the snapshots using the following command:
```
kubectl get volumesnapshot,volumesnapshotdatas
```{{execute T1}}

Now we're going to go ahead and do something stupid because it's Katacoda and we're here to learn.

```
POD=`kubectl get pods -l app=cassandra | grep Running | grep 1/1 | awk '{print $1}'`
kubectl exec -it $POD bash
psql
drop database pxdemo;
\l
\q
exit
```{{execute T1}}

Ok, so we deleted our database, what now? Restore your snapshot and cary on.

### Step: Restore the snapshot and see your data is still there

Snapshots are just like volumes so we can go ahead and use it to start a new instance of cassandraSQL. Note here that we're leaving the old instance to carry on with it's version of the volume and we're creating a brand new instance of cassandraSQL with the snapshot data!

First, lets create a new pvc, ``cat px-snap-pvc.yaml```{{execute T1}},  from the snapshot:
```
kubectl create -f px-snap-pvc.yaml
```{{execute T1}}

Now, lets look at the yaml: .

Now let's deploy a second cassandraSQL that uses this new PVC, ```cat cassandra-app-restore.yaml```{{execute T1}}, and make sure it came up.
```
kubectl create -f cassandra-app-restore.yaml
```{{execute T1}}

### Step: Verify cassandra pod is ready

Below commands wait till the cassandra pods are in ready state.
```
watch kubectl get pods -l app=cassandra-snap -o wide
```{{execute T1}}

When the pod is in Running state then then hit ```clear```{{execute interrupt}} to ctrl-c and clear the screen.
